<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>2048 Enhanced</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
* { box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }

body {
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}

/* Blurred background image */
body::before {
    content: "";
    position: absolute;
    inset: 0;
    background: url("2048.jpeg")
                center / cover no-repeat;
    filter: blur(12px);
    transform: scale(1.1); /* avoids edge blur gaps */
    z-index: -2;
}

/* Dark overlay for readability */
body::after {
    content: "";
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.55);
    z-index: -1;
}


.game {
    background: #faf8ef;
    padding: 20px;
    border-radius: 16px;
    width: 100%;
    max-width: 500px;
    box-shadow: 0 15px 60px rgba(0,0,0,0.4);
}

.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}
h1 { 
    color: #776e65; 
    margin: 0; 
    font-size: 48px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
}

.scores {
    display: flex;
    gap: 10px;
}

.score-box {
    background: #bbada0;
    color: white;
    padding: 10px 16px;
    border-radius: 10px;
    text-align: center;
    min-width: 70px;
}
.score-label {
    font-size: 11px;
    opacity: 0.8;
    text-transform: uppercase;
}
.score-value {
    font-size: 20px;
    font-weight: bold;
}

.controls {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.board-container {
    position: relative;
}

.board {
    position: relative;
    width: 100%;
    aspect-ratio: 1;
    background: #bbada0;
    border-radius: 12px;
    padding: 10px;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 10px;
}

.bg-cell {
    background: rgba(205, 193, 180, 0.5);
    border-radius: 8px;
}

.tile {
    position: absolute;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    transition: all 0.15s ease-in-out;
    animation: pop 0.2s ease-in-out;
}

@keyframes pop {
    0% { transform: scale(0); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.tile-new {
    animation: appear 0.2s ease-in-out;
}

@keyframes appear {
    0% { transform: scale(0); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

.tile-merge {
    animation: merge 0.2s ease-in-out;
}

@keyframes merge {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

.tile-2 { background: #eee4da; color: #776e65; }
.tile-4 { background: #ede0c8; color: #776e65; }
.tile-8 { background: #f2b179; color: #f9f6f2; }
.tile-16 { background: #f59563; color: #f9f6f2; }
.tile-32 { background: #f67c5f; color: #f9f6f2; }
.tile-64 { background: #f65e3b; color: #f9f6f2; }
.tile-128 { background: #edcf72; color: #f9f6f2; font-size: 0.9em; }
.tile-256 { background: #edcc61; color: #f9f6f2; font-size: 0.9em; }
.tile-512 { background: #edc850; color: #f9f6f2; font-size: 0.9em; }
.tile-1024 { background: #edc53f; color: #f9f6f2; font-size: 0.8em; }
.tile-2048 { background: #edc22e; color: #f9f6f2; font-size: 0.8em; }
.tile-4096 { background: #3c3a32; color: #f9f6f2; font-size: 0.8em; }
.tile-8192 { background: #3c3a32; color: #f9f6f2; font-size: 0.7em; }

button {
    flex: 1;
    padding: 12px;
    border: none;
    background: #8f7a66;
    color: white;
    border-radius: 10px;
    font-size: 16px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s;
}
button:hover { 
    background: #9f8a76; 
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}
button:active { transform: translateY(0); }

.overlay {
    position: absolute;
    inset: 0;
    background: rgba(238, 228, 218, 0.95);
    border-radius: 12px;
    display: none;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 100;
    animation: fadeIn 0.3s;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.overlay.show { display: flex; }

.overlay h2 {
    color: #776e65;
    font-size: 48px;
    margin: 0 0 20px 0;
}

.overlay button {
    width: 200px;
}

.instructions {
    text-align: center;
    margin-top: 15px;
    color: #776e65;
    font-size: 14px;
}

@media (max-width: 600px) {
    h1 { font-size: 36px; }
    .score-value { font-size: 16px; }
}
</style>
</head>

<body>

<div class="game">
    <div class="header">
        <h1>2048</h1>
        <div class="scores">
            <div class="score-box">
                <div class="score-label">Score</div>
                <div class="score-value" id="score">0</div>
            </div>
            <div class="score-box">
                <div class="score-label">Best</div>
                <div class="score-value" id="best">0</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button onclick="restart()">New Game</button>
        <button onclick="undo()">Undo</button>
    </div>

    <div class="board-container">
        <div class="board" id="board"></div>
        <div class="overlay" id="overlay">
            <h2 id="overlayText">Game Over!</h2>
            <button onclick="restart()">Try Again</button>
        </div>
    </div>

    <div class="instructions">
        Use arrow keys or swipe to play!<br>
        Join the tiles to reach 2048!
    </div>
</div>

<script>
const boardEl = document.getElementById("board");
const scoreEl = document.getElementById("score");
const bestEl = document.getElementById("best");
const overlayEl = document.getElementById("overlay");
const overlayText = document.getElementById("overlayText");

const size = 4;
let board = [];
let score = 0;
let bestScore = parseInt(localStorage.getItem('2048-best') || '0');
let history = [];
let moved = false;

bestEl.textContent = bestScore;

function createGrid() {
    boardEl.innerHTML = "";
    for (let i = 0; i < size * size; i++) {
        let bg = document.createElement("div");
        bg.className = "bg-cell";
        boardEl.appendChild(bg);
    }
}

function restart() {
    board = Array(size).fill().map(() => Array(size).fill(0));
    score = 0;
    history = [];
    moved = false;
    overlayEl.classList.remove('show');
    updateScore();
    createGrid();
    addTile();
    addTile();
    render();
}

function addTile() {
    let empty = [];
    board.forEach((row, r) =>
        row.forEach((v, c) => v === 0 && empty.push([r, c]))
    );
    if (!empty.length) return false;

    let [r, c] = empty[Math.floor(Math.random() * empty.length)];
    let val = Math.random() < 0.9 ? 2 : 4;
    board[r][c] = val;
    return true;
}

function getTilePosition(row, col) {
    const boardRect = boardEl.getBoundingClientRect();
    const cellSize = (boardRect.width - 10 * 5) / 4;
    const left = 10 + col * (cellSize + 10);
    const top = 10 + row * (cellSize + 10);
    return { left, top, size: cellSize };
}

function render(mergedTiles = []) {
    const existingTiles = boardEl.querySelectorAll('.tile');
    const tileMap = new Map();
    
    existingTiles.forEach(tile => {
        const key = tile.dataset.key;
        tileMap.set(key, tile);
    });

    board.forEach((row, r) => {
        row.forEach((val, c) => {
            if (val === 0) return;
            
            const key = `${r}-${c}`;
            const pos = getTilePosition(r, c);
            
            let tile = tileMap.get(key);
            
            if (!tile) {
                tile = document.createElement("div");
                tile.className = `tile tile-${val}`;
                tile.textContent = val;
                tile.dataset.key = key;
                tile.classList.add('tile-new');
                boardEl.appendChild(tile);
            } else {
                tile.className = `tile tile-${val}`;
                tile.textContent = val;
                tileMap.delete(key);
                
                if (mergedTiles.includes(key)) {
                    tile.classList.add('tile-merge');
                    setTimeout(() => tile.classList.remove('tile-merge'), 200);
                }
            }
            
            tile.style.left = pos.left + 'px';
            tile.style.top = pos.top + 'px';
            tile.style.width = pos.size + 'px';
            tile.style.height = pos.size + 'px';
            tile.style.fontSize = pos.size * 0.5 + 'px';
            tile.style.lineHeight = pos.size + 'px';
        });
    });

    tileMap.forEach(tile => tile.remove());
}

function slideRow(row) {
    let arr = row.filter(v => v);
    let merged = [];
    
    for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] === arr[i + 1]) {
            arr[i] *= 2;
            score += arr[i];
            merged.push(i);
            arr.splice(i + 1, 1);
        }
    }
    
    while (arr.length < size) arr.push(0);
    return { row: arr, merged };
}

function move(dir) {
    history.push({
        board: JSON.parse(JSON.stringify(board)),
        score: score
    });

    let oldBoard = JSON.stringify(board);
    let mergedTiles = [];
    moved = false;

    if (dir === "left") {
        board = board.map((row, r) => {
            const result = slideRow(row);
            result.merged.forEach(i => mergedTiles.push(`${r}-${i}`));
            return result.row;
        });
    }
    else if (dir === "right") {
        board = board.map((row, r) => {
            const reversed = row.slice().reverse();
            const result = slideRow(reversed);
            result.merged.forEach(i => mergedTiles.push(`${r}-${size - 1 - i}`));
            return result.row.reverse();
        });
    }
    else if (dir === "up") {
        for (let c = 0; c < size; c++) {
            let col = board.map(row => row[c]);
            const result = slideRow(col);
            result.merged.forEach(i => mergedTiles.push(`${i}-${c}`));
            result.row.forEach((val, r) => board[r][c] = val);
        }
    }
    else if (dir === "down") {
        for (let c = 0; c < size; c++) {
            let col = board.map(row => row[c]).reverse();
            const result = slideRow(col);
            result.merged.forEach(i => mergedTiles.push(`${size - 1 - i}-${c}`));
            result.row.reverse().forEach((val, r) => board[r][c] = val);
        }
    }

    if (oldBoard !== JSON.stringify(board)) {
        moved = true;
        updateScore();
        render(mergedTiles);
        
        setTimeout(() => {
            addTile();
            render();
            checkGameOver();
        }, 150);
    } else {
        history.pop();
    }
}

function updateScore() {
    scoreEl.textContent = score;
    if (score > bestScore) {
        bestScore = score;
        bestEl.textContent = bestScore;
        localStorage.setItem('2048-best', bestScore);
    }
}

function undo() {
    if (history.length === 0) return;
    
    const prev = history.pop();
    board = prev.board;
    score = prev.score;
    updateScore();
    render();
    overlayEl.classList.remove('show');
}

function checkGameOver() {
    // Check for 2048 win
    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
            if (board[r][c] === 2048) {
                overlayText.textContent = "You Win!";
                overlayEl.classList.add('show');
                return;
            }
        }
    }

    // Check for empty cells
    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
            if (board[r][c] === 0) return;
        }
    }

    // Check for possible merges
    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
            const val = board[r][c];
            if (c < size - 1 && board[r][c + 1] === val) return;
            if (r < size - 1 && board[r + 1][c] === val) return;
        }
    }

    overlayText.textContent = "Game Over!";
    overlayEl.classList.add('show');
}

// Keyboard controls
document.addEventListener("keydown", e => {
    if (e.key.includes("Arrow")) {
        e.preventDefault();
        move(e.key.replace("Arrow", "").toLowerCase());
    }
});

// Touch controls
let touchStartX = 0;
let touchStartY = 0;

boardEl.addEventListener('touchstart', e => {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
});

boardEl.addEventListener('touchend', e => {
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;
    
    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;
    
    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) {
        move(dx > 0 ? 'right' : 'left');
    } else if (Math.abs(dy) > 30) {
        move(dy > 0 ? 'down' : 'up');
    }
});

restart();
</script>

</body>
</html>